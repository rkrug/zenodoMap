---
title: "Zenodo Network Explorer App Guide"
format:
  html:
    toc: true
    embed-resources: true
    meremaid: true
---

## Overview

This document describes how the Shiny app works, what each function does, and how user actions drive the data flow. It also includes flow charts, sequence diagrams, and step-by-step R code for running the process outside the UI.

## Architecture at a Glance

The app has two primary stages:

1. **Load metadata** (via Zenodo API fetch or RDS upload).
2. **Build outputs** (metadata table and graph) from the cached records.

### Data Objects

- **Records**: a list of Zenodo record objects (as returned by the Zenodo API).
- **Cache**: `records_val()` stores the records and request metadata.
- **Graph**: node/edge data frames generated by `build_graph()`.

## Flow Charts

### Fetch flow (API)

```{mermaid}
flowchart TD
  A[User clicks Fetch metadata] --> B[build_query + choose per_page]
  B --> C[zenodo_search_auth page 1]
  C --> D{Response OK?}
  D -- No --> E[Capture error and status]
  D -- Yes --> F[Store hits and total_hits]
  F --> G{More pages needed?}
  G -- Yes --> H[zenodo_search_auth next page]
  H --> F
  G -- No --> I[Trim to max records]
  I --> J[Extract keywords]
  J --> K[Update keyword selector]
  K --> L[Cache records]
  L --> M[Trigger graph refresh]
```

### Upload flow (RDS)

```{mermaid}
flowchart TD
  A[User selects RDS file] --> B[readRDS]
  B --> C[sanitize_records]
  C --> D{Valid records?}
  D -- No --> E[Show error]
  D -- Yes --> F[Cache records]
  F --> G[Trigger graph refresh]
```

### Graph refresh flow

```{mermaid}
flowchart TD
  A[Graph refresh triggered] --> B[sanitize_records]
  B --> C[filter_by_keywords]
  C --> D[extract_relations + build_concept_map]
  D --> E[build_graph]
  E --> F[Render graph + table]
```

## Sequence Diagram

```{mermaid}
sequenceDiagram
  participant U as User
  participant UI as Shiny UI
  participant API as Zenodo API
  participant S as Server
  U->>UI: Fetch metadata
  UI->>S: input$fetch
  S->>API: zenodo_search_auth (page 1..n)
  API-->>S: JSON records
  S->>S: sanitize_records + cache
  S->>UI: update keyword choices
  S->>UI: graph refresh
  U->>UI: Adjust graph filters
  UI->>S: graph_trigger
  S->>S: build_graph + records_to_table
  S-->>UI: Graph + table
```

## Function Reference

### API and parsing

- `build_api_url()` builds a URL string for the Zenodo API call.
- `zenodo_search()` and `zenodo_search_auth()` execute the API request and parse JSON.
- `zenodo_fetch_record()` fetches an individual record for expansion.
- `zenodo_id_from_identifier()` extracts record ids from DOIs or record URLs.
- `extract_doi()` extracts DOI strings from identifiers for table display.

### Records and filtering

- `normalize_records()` and `sanitize_records()` ensure a consistent list of valid records.
- `normalize_keywords()` standardizes keyword tokens for matching.
- `filter_by_keywords()` returns a subset of records based on keyword selection.
- `records_to_table()` returns a display table with Title, DOI, and related items.

### Relations and graph building

- `build_concept_map()` maps concept DOIs to the latest version in the fetched set.
- `extract_relations()` lists relation types between community records.
- `build_graph()` creates `nodes` and `edges` data frames, applying filters and colors.

### Query building

- `build_query()` returns a Zenodo query string or `NULL`.

## Step-by-step R Example

This example runs the same steps as the UI without launching Shiny.

```r
# Load functions
source("app.R")

# 1) Build the query
community <- "ipbes"
query <- build_query("")

# 2) Fetch one or more pages from the API
per_page <- 25
raw <- zenodo_search_auth(
  query = query,
  community = community,
  size = per_page,
  page = 1,
  token = "" # optional token
)
records <- raw$hits$hits

# 3) Sanitize and filter records
records <- sanitize_records(records)
records <- filter_by_keywords(records, keywords_text = "")

# 4) Build relation choices and graph
community_ids <- vapply(records, function(rec) as.character(rec$id), character(1))
concept_map <- build_concept_map(records)
relations <- extract_relations(records, community_ids, concept_map)

graph <- build_graph(
  records = records,
  depth = 1,
  max_expand = length(records),
  allowed_relations = relations,
  community_ids = community_ids,
  community_only = FALSE,
  title_map = vapply(records, function(rec) rec$metadata$title %||% "", character(1)),
  concept_map = concept_map
)

# 5) Inspect outputs
head(graph$nodes)
head(graph$edges)

# 6) Build the table
tbl <- records_to_table(records)
head(tbl)
```

## Notes

- The app keeps the dataset as a list of records throughout.
- Concept DOIs in relations are mapped to the latest version found in the fetched records.
- If you use an RDS upload, ensure it contains a list of record objects with `id` and `metadata`.
