# Zenodo Network Explorer App Guide

``` r
# library(zenodoMap)
```

## Overview

This vignette describes how the Shiny app works, what each function
does, and how user actions drive the data flow. It also includes flow
charts, sequence diagrams, and step-by-step R code for running the
process outside the UI.

## Architecture at a Glance

The app has two primary stages:

1.  **Load metadata** (via Zenodo API fetch or RDS upload).
2.  **Build outputs** (metadata table and graph) from the cached
    records.

### Data Objects

- **Records**: a list of Zenodo record objects (as returned by the
  Zenodo API).
- **Cache**: `records_val()` stores the records and request metadata.
- **Graph**: node/edge data frames generated by
  [`build_graph()`](https://rkrug.github.io/zenodoMap/reference/build_graph.md).

## Flow Charts

### Fetch flow (API)

``` mermaid
flowchart TD
  A[User clicks Fetch metadata] --> B[build_query + choose per_page]
  B --> C[zenodo_search_auth page 1]
  C --> D{Response OK?}
  D -- No --> E[Capture error and status]
  D -- Yes --> F[Store hits and total_hits]
  F --> G{More pages needed?}
  G -- Yes --> H[zenodo_search_auth next page]
  H --> F
  G -- No --> I[Trim to max records]
  I --> J[Extract keywords]
  J --> K[Update keyword selector]
  K --> L[Cache records]
  L --> M[Trigger graph refresh]
```

### Upload flow (RDS)

``` mermaid
flowchart TD
  A[User selects RDS file] --> B[readRDS]
  B --> C[sanitize_records]
  C --> D{Valid records?}
  D -- No --> E[Show error]
  D -- Yes --> F[Cache records]
  F --> G[Trigger graph refresh]
```

### Graph refresh flow

``` mermaid
flowchart TD
  A[Graph refresh triggered] --> B[sanitize_records]
  B --> C[filter_by_keywords]
  C --> D[extract_relations + build_concept_map]
  D --> E[build_graph]
  E --> F[Render graph + table]
```

## Sequence Diagram

``` mermaid
sequenceDiagram
  participant U as User
  participant UI as Shiny UI
  participant API as Zenodo API
  participant S as Server
  U->>UI: Fetch metadata
  UI->>S: input$fetch
  S->>API: zenodo_search_auth (page 1..n)
  API-->>S: JSON records
  S->>S: sanitize_records + cache
  S->>UI: update keyword choices
  S->>UI: graph refresh
  U->>UI: Adjust graph filters
  UI->>S: graph_trigger
  S->>S: build_graph + records_to_table
  S-->>UI: Graph + table
```

## Function Reference

### API and parsing

- [`build_api_url()`](https://rkrug.github.io/zenodoMap/reference/build_api_url.md)
  builds a URL string for the Zenodo API call.
- [`zenodo_search()`](https://rkrug.github.io/zenodoMap/reference/zenodo_search.md)
  and
  [`zenodo_search_auth()`](https://rkrug.github.io/zenodoMap/reference/zenodo_search_auth.md)
  execute the API request and parse JSON.
- [`zenodo_fetch_record()`](https://rkrug.github.io/zenodoMap/reference/zenodo_fetch_record.md)
  fetches an individual record for expansion.
- [`zenodo_id_from_identifier()`](https://rkrug.github.io/zenodoMap/reference/zenodo_id_from_identifier.md)
  extracts record ids from DOIs or record URLs.
- [`extract_doi()`](https://rkrug.github.io/zenodoMap/reference/extract_doi.md)
  extracts DOI strings from identifiers for table display.

### Records and filtering

- [`normalize_records()`](https://rkrug.github.io/zenodoMap/reference/normalize_records.md)
  and
  [`sanitize_records()`](https://rkrug.github.io/zenodoMap/reference/sanitize_records.md)
  ensure a consistent list of valid records.
- [`normalize_keywords()`](https://rkrug.github.io/zenodoMap/reference/normalize_keywords.md)
  standardizes keyword tokens for matching.
- [`filter_by_keywords()`](https://rkrug.github.io/zenodoMap/reference/filter_by_keywords.md)
  returns a subset of records based on keyword selection.
- [`records_to_table()`](https://rkrug.github.io/zenodoMap/reference/records_to_table.md)
  returns a display table with Title, DOI, and related items.

### Relations and graph building

- [`build_concept_map()`](https://rkrug.github.io/zenodoMap/reference/build_concept_map.md)
  maps concept DOIs to the latest version in the fetched set.
- [`extract_relations()`](https://rkrug.github.io/zenodoMap/reference/extract_relations.md)
  lists relation types between community records.
- [`build_graph()`](https://rkrug.github.io/zenodoMap/reference/build_graph.md)
  creates `nodes` and `edges` data frames, applying filters and colors.

### Query building

- [`build_query()`](https://rkrug.github.io/zenodoMap/reference/build_query.md)
  returns a Zenodo query string or `NULL`.

## Step-by-step R Example

This example runs the same steps as the UI without launching Shiny.
Functions are internal; use `:::` here intentionally.

``` r
library(zenodoMap)

# 1) Build the query
community <- "ipbes"
query <- zenodoMap:::build_query("")

# 2) Fetch one or more pages from the API
per_page <- 25
raw <- zenodoMap:::zenodo_search_auth(
  query = query,
  community = community,
  size = per_page,
  page = 1,
  token = "" # optional token
)
records <- raw$hits$hits

# 3) Sanitize and filter records
records <- zenodoMap:::sanitize_records(records)
records <- zenodoMap:::filter_by_keywords(records, keywords_text = "")

# 4) Build relation choices and graph
community_ids <- vapply(records, function(rec) as.character(rec$id), character(1))
concept_map <- zenodoMap:::build_concept_map(records)
relations <- zenodoMap:::extract_relations(records, community_ids, concept_map)

graph <- zenodoMap:::build_graph(
  records = records,
  depth = 1,
  max_expand = length(records),
  allowed_relations = relations,
  community_ids = community_ids,
  community_only = FALSE,
  title_map = vapply(records, function(rec) rec$metadata$title %||% "", character(1)),
  concept_map = concept_map
)

# 5) Inspect outputs
head(graph$nodes)
head(graph$edges)

# 6) Build the table
tbl <- zenodoMap:::records_to_table(records)
head(tbl)
```

## Notes

- The app keeps the dataset as a list of records throughout.
- Concept DOIs in relations are mapped to the latest version found in
  the fetched records.
- If you use an RDS upload, ensure it contains a list of record objects
  with `id` and `metadata`.
